1.Thread
    currentThread :当前正在执行的线程
    getName:线程的名字

2. 继承自 Thread 和 Runnable 接口的比较
    a) 实现 Runnable 接口：
      还可以继承其他的类
      多个线程共享同一个 target 对象，适合多个线程处理同一份资源
    b) 继承自Thread:
      不能继承其他的类

3. 线程生命周期
新建(new)状态，就绪(runnable)状态,运行(running)状态，阻塞(blocked)状态,死亡(dead)状态

新建状态：当线程使用了new 新建了一个线程，线程就属于新建状态，在虚拟机中已经分配了存储空间并且初始化了变量
就绪状态：当线程调用了start方法，就属于就绪状态，虚拟机会创建 方法调用栈 和程序计数器 	，只表示该线程可以运行，但是并没有开始运行，何时运行取决于
	JVM的线程调度
运行状态：处于就绪状态的线程得到 获得的CPU，执行run 方法线程执行体，该线程 属于 运行状态

阻塞状态：
 发生如下情况线程进入阻塞状态
	a.线程调用sleep 方法 主动放弃所占有的 处理器资源
	b.线程调用了一个阻塞I/O方法，在该方法返回之前，线程被阻塞
	c.线程试图获取一个同步监视器，但是同步监视器被其它线程所占有
	d.线程在等待某个通知(notify)
	e.程序调用线程的suspend，将线程挂起
	
 解除阻塞的方法：
	a。调用sleep方法的线程，过了sleep时间
	b。线程调用阻塞I/O方法，已经返回
	c.线程成功取得试图获得的同步监视器
	d.线程等待到 需要的通知
	e.处于挂起的线程调用了resume 方法
	
	线程只能从阻塞状态 到就绪状态
	线程调用yield 方法，是线程从运行状态 到就绪状态
	
线程死亡：
  run方法运行完成，程序正常退出
  线程抛出一个为捕获的Exception 或者ERRor
  直接调用线程的stop方法  