1.Thread
    currentThread :当前正在执行的线程
    getName:线程的名字

2. 继承自 Thread 和 Runnable 接口的比较
    a) 实现 Runnable 接口：
      还可以继承其他的类
      多个线程共享同一个 target 对象，适合多个线程处理同一份资源
    b) 继承自Thread:
      不能继承其他的类

3. 线程生命周期
新建(new)状态，就绪(runnable)状态,运行(running)状态，阻塞(blocked)状态,死亡(dead)状态

新建状态：当线程使用了new 新建了一个线程，线程就属于新建状态，在虚拟机中已经分配了存储空间并且初始化了变量
就绪状态：当线程调用了start方法，就属于就绪状态，虚拟机会创建 方法调用栈 和程序计数器 	，只表示该线程可以运行，但是并没有开始运行，何时运行取决于
	JVM的线程调度
运行状态：处于就绪状态的线程得到 获得的CPU，执行run 方法线程执行体，该线程 属于 运行状态

阻塞状态：
 发生如下情况线程进入阻塞状态
	a.线程调用sleep 方法 主动放弃所占有的 处理器资源
	b.线程调用了一个阻塞I/O方法，在该方法返回之前，线程被阻塞
	c.线程试图获取一个同步监视器，但是同步监视器被其它线程所占有
	d.线程在等待某个通知(notify)
	e.程序调用线程的suspend，将线程挂起
	
 解除阻塞的方法：
	a。调用sleep方法的线程，过了sleep时间
	b。线程调用阻塞I/O方法，已经返回
	c.线程成功取得试图获得的同步监视器
	d.线程等待到 需要的通知
	e.处于挂起的线程调用了resume 方法
	
	线程只能从阻塞状态 到就绪状态
	线程调用yield 方法，是线程从运行状态 到就绪状态
	
线程死亡：
  run方法运行完成，程序正常退出
  线程抛出一个为捕获的Exception 或者ERRor
  直接调用线程的stop方法

 守护进程：后台进程
    当前台进程死亡的时候，后台进程也随之死亡
    把线程设置为 后台进程的时候，必须要在 线程启动之前
    JVM的垃圾回收线程，就是一个后台线程
 线程的join 方法
    在一个线程的执行流中，调用另一个线程的join 方法，调用该方法的线程将会被阻塞，直到被join 的
    线程，执行完成
    例子：A线程调用B线程的join 方法，则A线程被阻塞，直到 B线程执行完成

 线程的sleep方法
    调用线程的sleep方法，会暂停该线程，进入到阻塞状态

 线程的yield
    调用yield 方法，会暂停当前线程，并让该线程进入到 就绪状态，只有优先级 和当前线程相同或者优先级
    比当前线程高的 就绪状态的线程 才会获得执行机会

 sleep 和 yield的对比
    1.sleep方法暂停之后，会给其它方法的执行机会，不理会其它线程的优先级，而yield 方法，暂停之后，之后让优先级
    大于等于该线程优先级的线程执行机会
    2.sleep方法，会让当前转入阻塞状态，知道阻塞结束，进入就绪状态，而yield 方法，会让线程进入 阻塞状态
    3.sleep 方法会抛出InterruptedException ,而yield 方法不会抛出异常

 为了解决多线程所引起的共享变了安全的问题 引入了 同步监视器
 用法：
    synchronized(obj){
    }
 解释：obj 就是同步监视器，在执行同步代码块之前 ，必须先获得同步监视器的锁定

 任何时刻，只能有一个线程获得对同步监视器的锁定，当同步代码块执行结束，释放 对同步监视器的锁定